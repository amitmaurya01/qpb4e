# -*- coding: utf-8 -*-
"""Chapter_09.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/github/nceder/qpb4e/blob/main/code/Chapter%2009/Chapter_09.ipynb

# 9 Functions

# Basic function definitions
"""

def fact(n):
    '''Return the factorial of the given number.'''
    r = 1
    while n > 0:
        r = r * n
        n = n - 1
    return r

fact(4)

x = fact(4)
x

"""# 9.2 Function parameter options
## 9.2.1 positional parameters
"""

def power(x, y):
    r = 1
    while y > 0:
        r = r * x
        y = y - 1
    return r

power(3, 3)

power(3)

def power(x, y=2):
    r = 1
    while y > 0:
        r = r * x
        y = y - 1
    return r

power(3, 3)

power(3)

"""## 9.2.2 Passing arguments by parameter name

"""

power(y=2, x=3)

"""## 9.2.3 Variable numbers of arguments"""

def maximum(*numbers):    #A
    if len(numbers) == 0:
        return None
    else:
        maxnum = numbers[0]   #B
        for n in numbers[1:]:
            if n > maxnum:
                maxnum = n
        return maxnum

maximum(3, 2, 8)

maximum(1, 5, 9, -2, 2)

def example_fun(x, y, **other):  #A
    print(f"x: {x}, y: {y}, keys in 'other': {list(other.keys())}")
    other_total = 0
    for k in other.keys():
        other_total = other_total + other[k]
    print(f"The total of values in 'other' is {other_total}")

example_fun(2, y="1", foo=3, bar=4)

"""### Quick Check: Functions and parameters
How would you write a function that could take any number of unnamed arguments and print their values out in reverse order?

What do you need to do to create a procedure or void function—that is, a function with no return value?

**Either don’t return a value (use a bare return) or don't use a return statement at all.**

What happens if you capture the return value of a function with a variable?

**The only result is that you can use that value, whatever it might be.**
"""

def my_funct(*params):
    for i in reversed(params):
        print(i)

my_funct(1,2,3,4)

"""#9.3 Mutable objects as arguments"""

def f(n, list1, list2):
   list1.append(3)
   list2 = [4, 5, 6]
   n = n + 1

x = 5
y = [1, 2]
z = [4, 5]
f(x, y, z)
x, y, z

def odd_numbers(test_list, odds):
  for number in test_list:
    if number % 2:
      odds.append(number)
  return odds

odds = []
odds = odd_numbers([1, 5, 7, 9, 10], odds)
odds

def odd_numbers(test_list, odds=[]):
  for number in test_list:
    if number % 2:
      odds.append(number)
  return odds


odds = odd_numbers([1, 5, 7, 9, 10])
odds

odds = odd_numbers([1, 5, 7, 9, 10])
odds

"""### Quick Check: Mutable function parameters
What would be the result of changing a list or dictionary that was passed into a function as a parameter value? Which operations would be likely to create changes that would be visible outside the function? What steps might you take to minimize that risk?

**The changes would persist for future uses of the default parameter. Operations such as adding and deleting elements, as well as changing the value of an element, are particularly likely to be problems. To minimize the risk, it's better not to use mutable types as default parameters.**

# 9.4 Local, nonlocal, and global variables
"""

def fact(n):
    """Return the factorial of the given number."""
    r = 1
    while n > 0:
        r = r * n
        n = n - 1
    return r

def fun():
    global a
    a = 1
    b = 2

a = "one"
b = "two"

fun()
a

b

# file 9.1 nonlocal.py
g_var = 0               #A
nl_var = 0               #B
print("top level-> g_var: {0} nl_var: {1}".format(g_var, nl_var))
def test():
    nl_var = 2              #C
    print("in test-> g_var: {0} nl_var: {1}".format(g_var, nl_var))
    def inner_test():

        global g_var         #D
        nonlocal nl_var      #E
        g_var = 1
        nl_var = 4
        print("in inner_test-> g_var: {0} nl_var: {1}".format(g_var,
                                                              nl_var))

    inner_test()
    print("in test-> g_var: {0} nl_var: {1}".format(g_var, nl_var))

test()
print("top level-> g_var: {0} nl_var: {1}".format(g_var, nl_var))

"""### Try This: Global vs. local variables
Assuming that `x = 5`, what will be the value of `x` after `funct_1()` below executes? After `funct_2()` executes?

```python
def funct_1():
    x = 3
def funct_2():
    global x
    x = 2
```

**After calling funct_1(), x will be unchanged; after funct_2(), the value in the global x will be 2.**
"""

x = 0
def funct_1():
    x = 3
def funct_2():
    global x
    x = 2

funct_1()
x

funct_2()
x

"""# 9.5 Assigning functions to variables"""

def f_to_kelvin(degrees_f):
    return 273.15 + (degrees_f - 32) * 5 / 9

def c_to_kelvin(degrees_c):
    return 273.15 + degrees_c

abs_temperature = f_to_kelvin
abs_temperature(32)

abs_temperature = c_to_kelvin
abs_temperature(0)

t = {'FtoK': f_to_kelvin, 'CtoK': c_to_kelvin}
t['FtoK'](32)

t['CtoK'](0)

"""# 9.6 Lambda expressions"""

t2 = {'FtoK': lambda deg_f: 273.15 + (deg_f - 32) * 5 / 9,
      'CtoK': lambda deg_c: 273.15 + deg_c}
t2['FtoK'](32)

"""# 9.7 Generator functions"""

def four():
    x = 0                    #A
    while x < 4:
        print("in generator, x =", x)
        yield x                            #B
        x += 1     #C

for i in four():
    print(f"Value from generator {i}")

def subgen(x):
    for i in range(x):
        yield i

def gen(y):
    yield from subgen(y)

for q in gen(6):
    print(q)

2 in four()

5 in four()

"""### Quick Check: Generator functions
What would you need to modify in the previous code for the function `four()`to make it work for any number? What would you need to add to allow the starting point to also be set?

"""

def four(limit):
    x = 0
    while x < limit:
        print("in generator, x =", x)
        yield x
        x += 1

for i in four(4):
    print(i)

# To specify the start:

def four(start, limit):
    x = start
    while x < limit:
        print("in generator, x =", x)
        yield x
        x += 1


for i in four(1, 4):
    print(i)

"""# 9.8 Decorators"""

def decorate(func):
    print("in decorate function, decorating", func.__name__)
    def wrapper_func(*args):
        print("Executing", func.__name__)
        return func(*args)
    return wrapper_func

def myfunction(parameter):
    print(parameter)

myfunction = decorate(myfunction)

myfunction("hello")

def decorate(func):
    print("in decorate function, decorating", func.__name__)
    def wrapper_func(*args):
        print("Executing", func.__name__)
        return func(*args)
    return wrapper_func

@decorate
def myfunction(parameter):
    print(parameter)

myfunction("hello")

"""### Try This: Decorators
How would you modify the code for the decorator function to remove unneeded messages and enclose the return value of the wrapped function in `"<html>"` and `"</html>"`, so that `myfunction ("hello")` would return `"<html>hello<html>"`?

"""

def decorate(func):
    def wrapper_func(*args):
        def inner_wrapper(*args):
                return_value = func(*args)
                return "<html>{}<html>".format(return_value)

        return inner_wrapper(*args)
    return wrapper_func

@decorate
def myfunction(parameter):
    return parameter

print(myfunction("Test"))

"""### Lab 9: Useful functions
Looking back at the labs in chapters 6 and 7, refactor that code into functions for cleaning and processing the data. The goal should be that most of the logic is moved into functions. Use your own judgment as to the types of functions and parameters, but keep in mind that functions should do just one thing, and they shouldn’t have any side effects that carry over outside the function.
"""

!wget https://raw.githubusercontent.com/nceder/qpb4e/main/code/Chapter%2006/moby_01.txt &> null  && echo Downloaded

# Author's version
import string
punct = str.maketrans('', '', string.punctuation)

def clean_line(line):
    """changes case and removes punctuation"""
    # make all one case
    cleaned_line = line.lower()

    # remove punctuation
    cleaned_line = cleaned_line.translate(punct)
    return cleaned_line


def get_words(line):
    """splits line into words, and rejoins with newlines"""
    words = line.split()
    return "\n".join(words) + "\n"


def count_words(words):
    """takes list of cleaned words, returns count dictionary"""
    word_count = {}
    for word in words:
        count = word_count.setdefault(word, 0)
        word_count[word] += 1
    return word_count


def word_stats(word_count):
    """Takes word count dictionary and returns top and bottom five entries"""
    word_list = list(word_count.items())
    word_list.sort(key=lambda x: x[1])
    least_common = word_list[:5]
    most_common = word_list[-1:-6:-1]
    return most_common, least_common

with open("moby_01.txt") as infile, open("moby_01_clean.txt", "w") as outfile:
    for line in infile:
        cleaned_line = clean_line(line)

        cleaned_words = get_words(cleaned_line)

        # write all words for line
        outfile.write(cleaned_words)

moby_words = []
with open('moby_01_clean.txt') as infile:
    for word in infile:
        if word.strip():
            moby_words.append(word.strip())


word_count = count_words(moby_words)

most, least = word_stats(word_count)
print("Most common words:")
for word in most:
    print(word)
print("\nLeast common words:")
for word in least:
    print(word)

"""### Original Colaboratory code"""

# prompt: Open the file moby_01_clean.txt and use a dictionary to count the
#         occurrences of each word. Do not use a Counter. Print the five
#         most common words and their number of occurrences. Print the
#         five least common words and their number of occurrences.

# Open the file and read the text into a variable.
with open('moby_01_clean.txt', 'r') as f:
  text = f.read()

# Split the text into words.
words = text.split()

# Create a dictionary to count the occurrences of each word.
word_counts = {}
for word in words:
  if word not in word_counts:
    word_counts[word] = 0
  word_counts[word] += 1

# Find the five most common words and their number of occurrences.
most_common = sorted(word_counts.items(), key=lambda item: item[1], reverse=True)[:5]

# Find the five least common words and their number of occurrences.
least_common = sorted(word_counts.items(), key=lambda item: item[1])[:5]

# Print the results.
print("Most common words:")
for word, count in most_common:
  print(f"{word}: {count}")

print("\nLeast common words:")
for word, count in least_common:
  print(f"{word}: {count}")

# Generated by Colaboratory
# prompt: Refactor the code in the previous 2 cells into functions for cleaning
#         and processing the data.  The goal should be that most of the logic is
#         moved into functions.

# Function to clean a line of text by converting it to lowercase and removing punctuation
def clean_line(line):
  line = line.lower()
  line = line.translate(str.maketrans('', '', string.punctuation))
  return line

# Function to split a line of text into words and write each word to a new line in a file
def write_words_to_file(line, output_file):
  words = line.split()
  for word in words:
    output_file.write(word + '\n')

# Function to count the occurrences of each word in a list of words
def count_word_occurrences(words):
  word_counts = {}
  for word in words:
    if word not in word_counts:
      word_counts[word] = 0
    word_counts[word] += 1
  return word_counts

# Function to find the most and least common words in a dictionary of word counts
def find_most_and_least_common_words(word_counts):
  most_common = sorted(word_counts.items(), key=lambda item: item[1], reverse=True)[:5]
  least_common = sorted(word_counts.items(), key=lambda item: item[1])[:5]
  return most_common, least_common

# Open the input file for reading
with open('moby_01.txt', 'r') as input_file:
  # Open the output file for writing
  with open('moby_01_clean.txt', 'w') as output_file:
    # Iterate over each line in the input file
    for line in input_file:
      # Clean the line of text
      clean_line = clean_line(line)

      # Write each word in the clean line to the output file
      write_words_to_file(clean_line, output_file)

# Open the file and read the text into a variable.
with open('moby_01_clean.txt', 'r') as f:
  text = f.read()

# Split the text into words.
words = text.split()

# Count the occurrences of each word.
word_counts = count_word_occurrences(words)

# Find the most and least common words.
most_common, least_common = find_most_and_least_common_words(word_counts)

# Print the results.
print("Most common words:")
for word, count in most_common:
  print(f"{word}: {count}")

print("\nLeast common words:")
for word, count in least_common:
  print(f"{word}: {count}")

"""### Original Copilot code"""

# Generated using CoPilot
# Prompt: or every line the file moby_01.txt, make everything lower case,
#         remove punctuation, and split into words.
#         Write the words one per line to the file moby_01_clean.txt.

import string

# Open the input file for reading
with open('moby_01.txt', 'r') as input_file:
    # Open the output file for writing
    with open('moby_01_clean.txt', 'w') as output_file:
        # Iterate over each line in the input file
        for line in input_file:
            # Convert the line to lowercase
            line = line.lower()

            # Remove punctuation from the line
            line = line.translate(str.maketrans('', '', string.punctuation))

            # Split the line into words
            words = line.split()

            # Write each word to the output file
            for word in words:
                output_file.write(word + '\n')

# Generated by Copilot
import string

def clean_line(line):
    # Convert the line to lowercase
    line = line.lower()

    # Remove punctuation from the line
    line = line.translate(str.maketrans('', '', string.punctuation))

    return line

def write_words_to_file(words, output_file):
    # Write each word to the output file
    for word in words:
        output_file.write(word + '\n')

def count_word_occurrences(words):
    # Count the occurrences of each word using a dictionary
    word_counts = {}
    for word in words:
        if word in word_counts:
            word_counts[word] += 1
        else:
            word_counts[word] = 1

    return word_counts

def print_common_words(word_counts, n):
    # Sort the word counts in descending order
    sorted_word_counts = sorted(word_counts.items(), key=lambda x: x[1], reverse=True)

    # Print the n most common words and their occurrences
    print(f"{n} most common words:")
    for word, count in sorted_word_counts[:n]:
        print(f"{word}: {count}")

def print_least_common_words(word_counts, n):
    # Sort the word counts in descending order
    sorted_word_counts = sorted(word_counts.items(), key=lambda x: x[1], reverse=True)

    # Print the n least common words and their occurrences
    print(f"{n} least common words:")
    for word, count in sorted_word_counts[-n:]:
        print(f"{word}: {count}")

def process_file(input_file_path, output_file_path):
    # Open the input file for reading
    with open(input_file_path, 'r') as input_file:
        # Open the output file for writing
        with open(output_file_path, 'w') as output_file:
            # Iterate over each line in the input file
            for line in input_file:
                # Clean the line
                cleaned_line = clean_line(line)

                # Split the line into words
                words = cleaned_line.split()

                # Write the words to the output file
                write_words_to_file(words, output_file)

def main():
    input_file_path = 'moby_01.txt'
    output_file_path = 'moby_01_clean.txt'

    # Process the file
    process_file(input_file_path, output_file_path)

    # Open the file
    with open(output_file_path, 'r') as file:
        # Read the file content
        content = file.read()

    # Split the content into words
    words = content.split()

    # Count word occurrences
    word_counts = count_word_occurrences(words)

    # Print the five most common words and their occurrences
    print_common_words(word_counts, 5)

    # Print the five least common words and their occurrences
    print_least_common_words(word_counts, 5)

if __name__ == "__main__":
    main()

