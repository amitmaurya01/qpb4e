# -*- coding: utf-8 -*-
"""Chapter_11.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/github/nceder/qpb4e/blob/main/code/Chapter%2011/Chapter_11.ipynb

# 11 Python programs

# 11.1 Creating a very basic program
"""

!wget https://raw.githubusercontent.com/nceder/qpb4e/main/code/Chapter%2011/script1.py &> null  && echo Downloaded

# Listing 11.1 File script1.py

def main():                              #A
    print("this is our first test script file")
main()

! python script1.py

"""## 11.1.2 Command-line arguments"""

!wget https://raw.githubusercontent.com/nceder/qpb4e/main/code/Chapter%2011/script2.py &> null  && echo Downloaded

"""```python
# Listing 11.2 File script2.py

import sys
def main():
    print("this is our second test script file")
    print(sys.argv)
main()
```
"""

! python script2.py arg1 arg2 3

"""## 11.1.4 Redirecting the input and output of a script"""

!wget https://raw.githubusercontent.com/nceder/qpb4e/main/code/Chapter%2011/replace.py &> null  && echo Downloaded
open("infile", "w").write("This line has the word zero and the number 0.")

"""```python
#Listing 11.3 File replace.py

import sys
def main():
   contents = sys.stdin.read()                     #A
   sys.stdout.write(contents.replace(sys.argv[1], sys.argv[2]))  #B
if __name__ == "__main__":
   main()
```

"""

! python replace.py zero 0 < infile > outfile

! cat outfile

"""# 11.1.5 The argparse module"""

!wget https://raw.githubusercontent.com/nceder/qpb4e/main/code/Chapter%2011/opts.py &> null  && echo Downloaded

"""```python
# Listing 11.4 File opts.py

from argparse import ArgumentParser

def main():
    parser = ArgumentParser()
    parser.add_argument("indent", type=int, help="indent for report")
    parser.add_argument("input_file", help="read data from this file")   #1
    parser.add_argument("-f", "--file", dest="filename",             #2
                  help="write report to FILE", metavar="FILE")
    parser.add_argument("-x", "--xray",
                  help="specify xray strength factor")
    parser.add_argument("-q", "--quiet",
                  action="store_false", dest="verbose", default=True, #3
                  help="don't print status messages to stdout")

    args = parser.parse_args()

    print("arguments:", args)

if __name__ == "__main__":
    main()
```
"""

! python opts.py -x100 -q -f outfile 2 arg2

"""## 11.1.6 Using the fileinput module"""

open("sole1.tst", "w").write(
    """## sole1.tst: test data for the sole function
0 0 0
0 100 0
##"""
)
open("sole2.tst", "w").write(
    """## sole2.tst: more test data for the sole function
12 15 0
##
100 100 0"""
)

!wget https://raw.githubusercontent.com/nceder/qpb4e/main/code/Chapter%2011/script4.py  &> null  && echo Downloaded

"""```python
# Listing 11.5 File script4.py

import fileinput
def main():
    for line in fileinput.input():
        if not line.startswith('##'):
            print(line, end="")
if __name__ == "__main__":
    main()
```
"""

! python script4.py sole1.tst sole2.tst

!wget https://raw.githubusercontent.com/nceder/qpb4e/main/code/Chapter%2011/script5.py &> null  && echo Downloaded

"""```python
# Listing 11.8 File script5.py

import fileinput
def main():
    for line in fileinput.input():
        if fileinput.isfirstline():
            print("<start of file {0}>".format(fileinput.filename()))
        print(line, end="")
if __name__ == "__main__":
    main()
```
"""

! python script5.py sole1.tst sole2.tst

"""### Quick Check: Scripts and arguments
Match the following ways of interacting with the command line and the correct use case for each:

|                                    |                                     |
|------------------------------------|-------------------------------------|
| Multiple argurments and options    | sys.agrv                            |
| No arguments or just one argument  | Use fileinput module                |
| Processing multiple files          | Redirect standard input and output  |
| Using the script as a filter       |	Use argparse module                |

#### Solution

|                                    |                                     |
|------------------------------------|-------------------------------------|
| Multiple argurments and options    | Use argparse module                 |
| No arguments or just one argument  | sys.argv                            |
| Processing multiple files          | Use fileinput module                |
| Using the script as a filter       | Redirect standard input and output  |

### Try This: Making a script executable

Experiment with executing scripts on your platform. Also try to redirect input and output into and out of your scripts.

# 11.3 Programs and modules
"""

!wget https://raw.githubusercontent.com/nceder/qpb4e/main/code/Chapter%2011/script6.py  &> null  && echo Downloaded

"""```python
# Listing 11.9 File script6.py

#! /usr/bin/env python3
import sys
# conversion mappings
_1to9dict = {'0': '', '1': 'one', '2': 'two', '3': 'three', '4': 'four',
             '5': 'five', '6': 'six', '7': 'seven', '8': 'eight',
             '9': 'nine'}
_10to19dict = {'0': 'ten', '1': 'eleven', '2': 'twelve',
               '3': 'thirteen', '4': 'fourteen', '5': 'fifteen',
               '6': 'sixteen', '7': 'seventeen', '8': 'eighteen',
               '9': 'nineteen'}
_20to90dict = {'2': 'twenty', '3': 'thirty', '4': 'forty', '5': 'fifty',
               '6': 'sixty', '7': 'seventy', '8': 'eighty', '9': 'ninety'}
def num2words(num_string):
    if num_string == '0':
        return'zero'
    if len(num_string) > 2:
        return "Sorry can only handle 1 or 2 digit numbers"
    num_string = '0' + num_string                   #A
    tens, ones = num_string[-2], num_string[-1]
    if tens == '0':
        return _1to9dict[ones]
    elif tens == '1':
        return _10to19dict[ones]
    else:
        return _20to90dict[tens] + ' ' + _1to9dict[ones]
def main():
    print(num2words(sys.argv[1]))        #1
if __name__ == "__main__":
    main()
```
"""

!python script6.py 59

!wget https://raw.githubusercontent.com/nceder/qpb4e/main/code/Chapter%2011/n2w.py &> null   && echo Downloaded

"""```python
# Listing 11.10 File n2w.py

#! /usr/bin/env python3
'''n2w: number to words conversion module: contains function
   num2words. Can also be run as a script
usage as a script: n2w num
           (Convert a number to its English word description)
           num: whole integer from 0 and 999,999,999,999,999 (commas are
           optional)
example: n2w 10,003,103
           for 10,003,103 say: ten million three thousand one hundred three
'''
import sys, string, argparse
_1to9dict = {'0': '', '1': 'one', '2': 'two', '3': 'three', '4': 'four',
             '5': 'five', '6': 'six', '7': 'seven', '8': 'eight',
             '9': 'nine'}
_10to19dict = {'0': 'ten', '1': 'eleven', '2': 'twelve',
               '3': 'thirteen', '4': 'fourteen', '5': 'fifteen',
               '6': 'sixteen', '7': 'seventeen', '8': 'eighteen',
               '9': 'nineteen'}
_20to90dict = {'2': 'twenty', '3': 'thirty', '4': 'forty', '5': 'fifty',
               '6': 'sixty', '7': 'seventy', '8': 'eighty', '9': 'ninety'}
_magnitude_list = [(0, ''), (3, ' thousand '), (6, ' million '),
                  (9, ' billion '), (12, ' trillion '),(15, '')]
def num2words(num_string):
    '''num2words(num_string): convert number to English words'''
    if num_string == '0':
        return 'zero'
    num_string = num_string.replace(",", "")
    num_length = len(num_string)
    max_digits = _magnitude_list[-1][0]
    if num_length > max_digits:

        return "Sorry, can't handle numbers with more than  " \
               "{0} digits".format(max_digits)

    num_string = '00' + num_string
    word_string = ''
    for mag, name in _magnitude_list:
        if mag >= num_length:
            return word_string
        else:
            hundreds, tens, ones = num_string[-mag-3], \
                 num_string[-mag-2], num_string[-mag-1]
            if not (hundreds == tens == ones == '0'):
                word_string = _handle1to999(hundreds, tens, ones) + \
                                            name + word_string
def _handle1to999(hundreds, tens, ones):
    if hundreds == '0':
        return _handle1to99(tens, ones)
    else:
        return _1to9dict[hundreds] + ' hundred ' + _handle1to99(tens, ones)
def _handle1to99(tens, ones):
    if tens == '0':
        return _1to9dict[ones]
    elif tens == '1':
        return _10to19dict[ones]
    else:
        return _20to90dict[tens] + ' ' + _1to9dict[ones]
def test():
    values = sys.stdin.read().split()
    for val in values:
        print("{0} = {1}".format(val, num2words(val)))
def main():
    parser = argparse.ArgumentParser(usage=__doc__)
    parser.add_argument("num", nargs='*')
    parser.add_argument("-t", "--test", dest="test",
                      action='store_true', default=False,
                      help="Test mode: reads from stdin")
    args = parser.parse_args()
    if args.test:
        test()
    else:
        try:
            result = num2words(args.num[0])
        except KeyError:
            parser.error('argument contains non-digits')
        else:
            print("For {0}, say: {1}".format(args.num[0], result))
if __name__ == '__main__':
    main()
else:
    print("n2w  loaded as a module")
```
"""

# Listing 11.11 File n2w.tst
open("n2w.tst", "w").write(
    """0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 98 99 100
101 102 900 901 999
999,999,999,999,999
1,000,000,000,000,000"""
)

! python n2w.py --test < n2w.tst

"""### Quick Check: Programs and modules

What issue is the use of if `__name__ == "__main__":` meant to prevent, and how does it do that? Can you think of any other way to prevent this issue?

#### Solution

When Python loads a module, all of its code is executed. By using the pattern above, you can have certain code run only if it's being executed as the main script file.

# 11.5 Lab 11: Creating a program

In chapter 8, you created a version of the UNIX `wc` utility to count the lines, words, and characters in a file. Now that you have more tools at your disposal, refactor that program to make it work more like the original. In particular, the program should have options to show only lines (`-l`), only words (`-w`), and only characters (`-c`). If none of those options is given, all three stats are displayed. But if any of these options is present, only the specified stats are shown.

For an extra challenge, have a look at the man page for `wc` on a Linux/UNIX system (`! man wc` in Colaboratory), and add the `-L` to show the longest line length. Feel free to try to implement the complete behavior as listed in the man page and test it against your system's `wc` utility.
"""

# Human (author) solution

open("wc.py", "w").write('''#!/usr/bin/env python3
# File: word_count_program.py
""" Reads a file and returns the number of lines, words,
    and characters - similar to the UNIX wc utility
"""
import sys
import argparse


def main():
    # initialze counts
    line_count = 0
    word_count = 0
    char_count = 0
    longest_line = 0

    parser = argparse.ArgumentParser(usage=__doc__)
    parser.add_argument("-c", "--characters",
                  action="store_true", dest="chars", default=False,
                  help="display number of characters")
    parser.add_argument("-w", "--words",
                  action="store_true", dest="words", default=False,
                  help="display number of words")
    parser.add_argument("-l", "--lines",
                  action="store_true", dest="lines", default=False,
                  help="display number of lines")
    parser.add_argument("-L", "--longest",
                  action="store_true", dest="longest", default=False,
                  help="display longest line length")
    parser.add_argument("filename", help="read data from this file")
    args = parser.parse_args()

    filename = args.filename    # open the file
    with  open(filename) as infile:
        for line in infile:
            line_count += 1
            char_count += len(line)
            words = line.split()
            word_count += len(words)
            if len(line) > longest_line:
                longest_line = len(line)

    default_args = any([getattr(args, _) for _ in ('chars', 'words', 'lines', 'longest')])

    if not default_args:
        args.chars = args.lines = args.words = True

    if args.lines:
        print(f"{line_count:3}", end=" ")
    if args.words:
        print(f"{word_count:4}", end=" ")
    if args.chars:
        print(f"{char_count:4}", end=" ")
    if args.longest:
        print(f'{longest_line}', end=" ")
    print(f'{filename}')

if __name__ == '__main__':
    main()
''')

# Generated by Copilot
#!/usr/bin/env python3

""" Reads a file and returns the number of lines, words,
    and characters - similar to the UNIX wc utility
"""

with open('word_count.tst') as infile:
    lines = infile.readlines()

line_count = len(lines)
word_count = sum(len(line.split()) for line in lines)
char_count = sum(len(line) for line in lines)

print(f"File has {line_count} lines, {word_count} words, {char_count} characters")

# Generated by Colaboratory
# prompt: Refactor the code in the previous cell into a commandline program
#         that works like the Unix wc utility, and supports the -l, -w, and
#         -c options, and the -L option. Output should be similar to output of wc.

#!/usr/bin/env python3

""" Reads a file and returns the number of lines, words,
    and characters - similar to the UNIX wc utility
"""

import argparse

def main():
    parser = argparse.ArgumentParser(usage=__doc__)
    parser.add_argument("filename", nargs='*')
    parser.add_argument("-l", "--lines", dest="lines",
                      action='store_true', default=False,
                      help="Show only line count")
    parser.add_argument("-w", "--words", dest="words",
                      action='store_true', default=False,
                      help="Show only word count")
    parser.add_argument("-c", "--chars", dest="chars",
                      action='store_true', default=False,
                      help="Show only character count")
    parser.add_argument("-L", "--longest", dest="longest",
                      action='store_true', default=False,
                      help="Show length of longest line")
    args = parser.parse_args()

    for filename in args.filename:
        with open(filename) as infile:
            lines = infile.readlines()

        line_count = len(lines)
        word_count = sum(len(line.split()) for line in lines)
        char_count = sum(len(line) for line in lines)
        longest_line_length = max(len(line) for line in lines)

        if args.lines:
            print(f"{line_count} {filename}")
        elif args.words:
            print(f"{word_count} {filename}")
        elif args.chars:
            print(f"{char_count} {filename}")
        elif args.longest:
            print(f"{longest_line_length} {filename}")
        else:
            print(f"{line_count} {word_count} {char_count} {filename}")

if __name__ == '__main__':
    main()

# Generated by Copilot
# wc.py

import argparse

def count_stats(file_path):
    with open(file_path) as infile:
        lines = infile.readlines()

    line_count = len(lines)
    word_count = sum(len(line.split()) for line in lines)
    char_count = sum(len(line) for line in lines)
    max_line_length = max(len(line) for line in lines)

    return line_count, word_count, char_count, max_line_length

def main():
    parser = argparse.ArgumentParser(description='Count lines, words, and characters in a file.')
    parser.add_argument('file', help='File to count')
    parser.add_argument('-l', '--lines', action='store_true', help='Count lines')
    parser.add_argument('-w', '--words', action='store_true', help='Count words')
    parser.add_argument('-c', '--chars', action='store_true', help='Count characters')
    parser.add_argument('-L', '--max-line-length', action='store_true', help='Print length of the longest line')
    args = parser.parse_args()

    line_count, word_count, char_count, max_line_length = count_stats(args.file)

    if args.lines:
        print(f'Lines: {line_count}')
    if args.words:
        print(f'Words: {word_count}')
    if args.chars:
        print(f'Characters: {char_count}')
    if args.max_line_length:
        print(f'Max line length: {max_line_length}')

if __name__ == '__main__':
    main()

# wc.py

import argparse
import os

def count_stats(file_path):
    with open(file_path) as infile:
        lines = infile.readlines()

    line_count = len(lines)
    word_count = sum(len(line.split()) for line in lines)
    byte_count = os.path.getsize(file_path)
    max_line_length = max(len(line) for line in lines)

    return line_count, word_count, byte_count, max_line_length

def main():
    parser = argparse.ArgumentParser(description='Count lines, words, and bytes in a file.')
    parser.add_argument('file', help='File to count')
    parser.add_argument('-l', '--lines', action='store_true', help='Count lines')
    parser.add_argument('-w', '--words', action='store_true', help='Count words')
    parser.add_argument('-c', '--bytes', action='store_true', help='Count bytes')
    parser.add_argument('-L', '--max-line-length', action='store_true', help='Print length of the longest line')
    args = parser.parse_args()

    line_count, word_count, byte_count, max_line_length = count_stats(args.file)

    if args.lines:
        print(line_count, end=' ')
    if args.words:
        print(word_count, end=' ')
    if args.bytes:
        print(byte_count, end=' ')
    if args.max_line_length:
        print(max_line_length, end=' ')
    if not any([args.lines, args.words, args.bytes, args.max_line_length]):
        print(f'{line_count} {word_count} {byte_count} {args.file}')
    else:
        print(args.file)

if __name__ == '__main__':
    main()

# make file executable
! chmod +x wc.py

# run on the file itself

! /content/wc.py  -L wc.py

# run wc on file itself
! wc  wc.py

# run on README in sample_data

! /content/wc.py  sample_data/README.md

# run wc on sample_data/README.md
! wc   sample_data/README.md