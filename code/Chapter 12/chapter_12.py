# -*- coding: utf-8 -*-
"""Chapter_12.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/github/nceder/qpb4e/blob/main/code/Chapter%2012/Chapter_12.ipynb

# Using the filesystem

## 12.2.2 The current working directory
"""

import os
os.getcwd()

os.listdir(os.curdir)

os.chdir('sample_data')    #A
os.getcwd()

"""## 12.2.3 Accessing directories with pathlib"""

import pathlib
cur_path = pathlib.Path()
cur_path.cwd()

"""## 12.2.4 Manipulating pathnames"""

import os
print(os.path.join('bin', 'utils', 'disktools'))

path1 = os.path.join('mydir', 'bin');
path2 = os.path.join('utils', 'disktools', 'chkdisk')
print(os.path.join(path1, path2))

import os
print(os.path.split(os.path.join('some', 'directory', 'path')))

import os
os.path.basename(os.path.join('some', 'directory', 'path.jpg'))

os.path.dirname(os.path.join('some', 'directory', 'path.jpg'))

os.path.splitext(os.path.join('some', 'directory', 'path.jpg'))

import os
os.path.expandvars('$HOME\\temp')

"""## 12.2.5 Manipulating pathnames with pathlib"""

from pathlib import Path
cur_path = Path()
print(cur_path.joinpath('bin', 'utils', 'disktools'))

cur_path / 'bin' / 'utils' / 'disktools'

cur_path = Path()
print(cur_path.joinpath('bin', 'utils', 'disktools'))

a_path = Path('bin/utils/disktools')
print(a_path.parts)

a_path = Path('some', 'directory', 'path.jpg')
a_path.name

print(a_path.parent)

a_path.suffix

"""##12.2.6 Useful constants and functions"""

import os
os.name

"""### Quick Check: Manipulating paths

How would you use the os module's functions to take a path to a file called `test.log` and create a new file path in the same directory for a file called `test.log.old`? How would you do the same thing using the `pathlib` module?
What path would you get if you created a pathlib `Path` object from `os.pardir`? Try it and find out.
"""

import os.path
old_path = os.path.abspath('test.log')
print(old_path)
new_path = '{}.{}'.format(old_path, "old")
print(new_path)

import pathlib
path = pathlib.Path('test.log')
abs_path = path.resolve()
print(abs_path)
new_path = str(abs_path) + ".old"
print(new_path)

test_path = pathlib.Path(os.pardir)
print(test_path)
test_path.resolve()

"""# 12.3 Getting information about files"""

import os
os.path.exists('/content/sample_data/')

os.path.exists('/content/sample_data/README.md')

os.path.exists('/content/sample_data/ljsljkflkjs')

os.path.isdir('/content/sample_data/')

os.path.isdir('/content/sample_data/README.md')

os.path.isfile('/content/sample_data/README.md')

"""## 12.3.1 Getting information about files with scandir"""

with os.scandir("..") as my_dir:
    for entry in my_dir:
        print(entry.name, entry.is_file())

"""# 12.4 More filesystem operations"""

os.chdir('/content/sample_data')
os.listdir(os.curdir)

import glob
glob.glob("*")

glob.glob("*json")

! touch a.tmp 1.tmp 2.tmp

glob.glob("?.tmp")

glob.glob("[0-9].tmp")

os.rename('README.md', 'README.md.old')
os.listdir(os.curdir)

os.remove('a.tmp')
os.listdir(os.curdir)

os.makedirs('mydir')
os.listdir(os.curdir)

os.path.isdir('mydir')

os.rmdir('mydir')
os.listdir(os.curdir)

"""## 12.4.1 More filesystem operations with pathlib

"""

new_path = cur_path.joinpath('/content', 'sample_data')
list(new_path.iterdir())

list(cur_path.glob("*"))

list(cur_path.glob("*json"))

list(cur_path.glob("?.tmp"))

list(cur_path.glob("[0-9].tmp"))

old_path = Path('README.md.old')
new_path = Path('README.md')
old_path.rename(new_path)
list(cur_path.iterdir())

new_path = Path('1.tmp')
new_path.unlink()
list(cur_path.iterdir())

new_path = Path ('mydir')
new_path.mkdir(parents=True)
list(cur_path.iterdir())

new_path.is_dir()

new_path = Path('mydir')
new_path.rmdir()
list(cur_path.iterdir())

"""# 12.6 Lab 12: More file operations

---

How might you calculate the total size of all files ending with .test that aren't symlinks in a directory? If your first answer was using `os` and `os.path`, also try it with `pathlib`, and vice versa.

Write some code that builds off your solution, and moves the .test files detected above to a new subdirectory in the same directory called 'backup'.

## 12.6.2 Solutions
### Human (author) solutions
"""

! cp california_housing_test.csv california_housing_test.csv.test
! cp california_housing_train.csv california_housing_train.csv.test
! mkdir subdir
! cp mnist_test.csv subdir/mnist_test.csv.test
! mkdir subdir/subdir2
! cp mnist_train_small.csv subdir/subdir2/mnist_train_small.csv.test

# Human (author) solution - pathlib library

import pathlib
cur_path = pathlib.Path(".")

size = 0
for text_path in cur_path.rglob("*.test"):
    if not text_path.is_symlink():
        size += text_path.stat().st_size

print(size)

"""#### Move files to backup directory"""

# Human (author) solution - pathlib library

import pathlib
cur_path = pathlib.Path(".")
new_path = pathlib.Path("backup")
new_path.mkdir(exist_ok=True)   #A

size = 0
for text_path in cur_path.rglob("*.test"):
    if not text_path.is_symlink():
        size += text_path.stat().st_size
        text_path.rename(new_path / text_path.name)   #B

print(size)

"""#### Refactor to use `os` library"""

! cp sample_data/california_housing_test.csv california_housing_test.csv.test
! cp california_housing_train.csv california_housing_train.csv.test
! cp mnist_test.csv subdir/mnist_test.csv.test
! cp mnist_train_small.csv subdir/subdir2/mnist_train_small.csv.test
! rm backup/*.test

# Human (author) solution - os library

import os
cur_path = "."

size = 0
for root, dirs, files in os.walk(os.curdir):   #A
    for file in files:      #B
        test_path = os.path.join(root, file)

        if (not os.path.islink(test_path) and
            os.path.splitext(test_path)[-1] == '.test'):  #C
            size += os.path.getsize(test_path)   #D
print(f"{size}")

# Human (author) solution - os library

import os

cur_path = "."
new_path = os.path.join(cur_path,"backup")

# create backup directory
os.makedirs(new_path, exist_ok=True)   #A
size = 0
for root, dirs, files in os.walk(cur_path,"sample_data"):
    for file in files:
        test_path = os.path.join(root, file)

        if (not os.path.islink(test_path)
          and os.path.splitext(test_path)[-1] == ".test"):
            size += os.path.getsize(test_path)
            os.rename(test_path, os.path.join(new_path,
                       os.path.basename(test_path)))   #B
print(f"{size}")

"""### Copilot solutions"""

! cp california_housing_test.csv california_housing_test.csv.test
! cp california_housing_train.csv california_housing_train.csv.test
! cp mnist_test.csv subdir/mnist_test.csv.test
! cp mnist_train_small.csv subdir/subdir2/mnist_train_small.csv.test
! rm backup/*.test

# Generated by Copilot - os library
# txt_file_size.py

import os

size = 0
for root, dirs, files in os.walk(os.curdir):
    for file in files:
        file_path = os.path.join(root, file)
        if not os.path.islink(file_path) and os.path.splitext(file)[1] == '.test':
            size += os.path.getsize(file_path)

print(f"Total size of all .test files that are not symlinks: {size} bytes")

"""#### Move to backup directory"""

# Generated by Copilot - os library
# txt_file_size_and_move.py

import os

import shutil

size = 0
os.makedirs('backup', exist_ok=True)
for root, dirs, files in os.walk(os.curdir):
    for file in files:
        file_path = os.path.join(root, file)
        if (not os.path.islink(file_path)
                and os.path.splitext(file)[1] == '.test'
                and "backup" not in file_path):
            size += os.path.getsize(file_path)
            shutil.move(file_path, 'backup')

print(f"Total size of all .test files that are not symlinks: {size} bytes")

"""#### Refactor with pathlib libarary"""

! cp california_housing_test.csv california_housing_test.csv.test
! cp california_housing_train.csv california_housing_train.csv.test
! cp mnist_test.csv subdir/mnist_test.csv.test
! cp mnist_train_small.csv subdir/subdir2/mnist_train_small.csv.test
! rm backup/*.test

# Generated by Copilot - pathlib library
# txt_file_size_and_move.py

from pathlib import Path

size = 0
backup_dir = Path('backup')
backup_dir.mkdir(exist_ok=True)

for file in Path().rglob('*'):
    if not file.is_symlink() and file.suffix == '.test':
        size += file.stat().st_size
        file.rename(backup_dir / file.name)

print(f"Total size of all .test files that are not symlinks: {size} bytes")

"""### Colaboratory solutions"""

! cp california_housing_test.csv california_housing_test.csv.test
! cp california_housing_train.csv california_housing_train.csv.test
! cp mnist_test.csv subdir/mnist_test.csv.test
! cp mnist_train_small.csv subdir/subdir2/mnist_train_small.csv.test
! rm backup/*.test

# Generated by Colaboratory - os libary
# prompt: Write a Python script to calculate the total size of all files with a
#         .test extension that are not symlinks in the current directory and subdirectories.

import os

total_size = 0

for root, _, files in os.walk('.'):
    for file in files:
        if file.endswith('.test') and not os.path.islink(os.path.join(root, file)):
            total_size += os.path.getsize(os.path.join(root, file))

print(f"Total size of .test files: {total_size} bytes")

"""#### Move to backup directory"""

# Generated by Colaboratory - os libary
# prompt: Modify that script in the previous cell to also move the files with a
#         .test extension to a subdirectory of the current directory called backup

import os

total_size = 0
backup_dir = os.path.join(os.getcwd(), 'backup')

# Create the backup directory if it doesn't exist
if not os.path.exists(backup_dir):
    os.makedirs(backup_dir)

for root, _, files in os.walk('.'):
    for file in files:
        if file.endswith('.test') and not os.path.islink(os.path.join(root, file)):
            total_size += os.path.getsize(os.path.join(root, file))
            # Move the file to the backup directory
            os.rename(os.path.join(root, file), os.path.join(backup_dir, file))

print(f"Total size of .test files: {total_size} bytes")

"""#### Refactor with pathlib libarary"""

! cp california_housing_test.csv california_housing_test.csv.test
! cp california_housing_train.csv california_housing_train.csv.test
! cp mnist_test.csv subdir/mnist_test.csv.test
! cp mnist_train_small.csv subdir/subdir2/mnist_train_small.csv.test
! rm backup/*.test

# this checks to see if the version of Python can run Path.walk()
import sys
from pathlib import Path

if sys.version_info.minor < 12:
  raise RuntimeError(f"Python version must be >= 3.12 to run Path.walk(), current version is {sys.version}")

# Generated by Colaboratory - pathlib libary
# prompt: Rewrite the script in the previous cell to use pathlib instead of os
#         and os.path. Do not use os or os.path modules

total_size = 0
backup_dir = Path.cwd().joinpath('backup')

# Create the backup directory if it doesn't exist
if not backup_dir.exists():
    backup_dir.mkdir(parents=True)

for root, _, files in Path('.').walk():
    for file in files:
        if file.endswith('.test') and not file.is_symlink():
            total_size += file.stat().st_size
            # Move the file to the backup directory
            file.rename(backup_dir.joinpath(file))

print(f"Total size of .test files: {total_size} bytes")

