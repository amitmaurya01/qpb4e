# -*- coding: utf-8 -*-
"""Chapter_13.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/github/nceder/qpb4e/blob/main/code/Chapter%2013/Chapter_13.ipynb

# 13 Reading and writing files

# 13.3 Opening files in write or other modes
"""

file_object = open("myfile", 'w')
file_object.write("Hello, World\n")
file_object.close()

"""# 13.4 Functions to read and write text or binary data"""

file_object = open("myfile", 'r')
count = 0
while file_object.readline() != "":
    count = count + 1
print(count)
file_object.close()

file_object = open("myfile", 'r')
print(len(file_object.readlines()))
file_object.close()

file_object = open("myfile", 'r')
count = 0
for line in file_object:
    count = count + 1
print(count)
file_object.close()

input_file = open("myfile", 'r')
lines = input_file.readlines()
input_file.close()
output = open("myfile2.txt", 'w')
output.writelines(lines)
output.close()

"""## 13.4.1 Using binary mode"""

input_file = open("myfile", 'rb')
header = input_file.read(4)
data = input_file.read()
input_file.close()

"""# 13.5 Reading and writing with pathlib"""

from pathlib import Path
p_text = Path('my_text_file')
p_text.write_text('Text file contents')

p_text.read_text()

p_binary = Path('my_binary_file')
p_binary.write_bytes(b'Binary file contents')

p_binary.read_bytes()

"""# 13.6 Screen input/output and redirection"""

x = input("enter file name to use: ")

x

x = int(input("enter your number: "))

x

import sys
print("Write to the standard output.")

sys.stdout.write("Write to the standard output.\n")

"""## Warning about Colaboratory and Jupyter

 Since Colaboratory (and Jupyter in general) takes more control of standard input and output, using `sys.__stdout__` for these examples (as shown in the book) won't work here as indicated; instead you need to save the old value of sys.stdout before changing it, and then restore the old value after using the redirected value.


"""

import sys
f = open("outfile.txt", 'w')
old_sys_stdout = sys.stdout
sys.stdout = f     #B
sys.stdout.writelines(["A first line.\n", "A second line.\n"])  #C
print("A line from the print function") #C
sys.stdout = old_sys_stdout
f.close()
! cat outfile.txt

f = open("outfile.txt", 'w')  #A
print("A first line.\n", "A second line.\n", file=f)  #B
f.close()

!cat outfile.txt

"""### Listing 13.1 File mio.py

```python

'''mio: module, (contains functions capture_output, restore_output,
     print_file, and clear_file )'''
import sys
_file_object = None
def capture_output(file="capture_file.txt"):
    '''capture_output(file='capture_file.txt'): redirect the standard
    output to 'file'.'''
    global _file_object
    print("output will be sent to file: {0}".format(file))
    print("restore to normal by calling 'mio.restore_output()'")
    _file_object = open(file, 'w')
    sys.stdout = _file_object

def restore_output():
    '''restore_output(): restore the standard output back to the
             default (also closes the capture file)'''
    global _file_object
    sys.stdout = sys.__stdout__
    _file_object.close()
    print("standard output has been restored back to normal")

def print_file(file="capture_file.txt"):
    '''print_file(file="capture_file.txt"): print the given file to the
         standard output'''
    f = open(file, 'r')
    print(f.read())
    f.close()

def clear_file(file="capture_file.txt"):
    '''clear_file(file="capture_file.txt"): clears the contents of the
         given file'''
    f = open(file, 'w')
    f.close()
```

**Execute the cell below to write the code to `mio.py`.**
"""

# Commented out IPython magic to ensure Python compatibility.
# %%writefile mio.py
# """mio: module, (contains functions capture_output, restore_output,
#      print_file, and clear_file )"""
# import sys
# _file_object = None
# def capture_output(file="capture_file.txt"):
#     """capture_output(file='capture_file.txt'): redirect the standard
#     output to 'file'."""
#     global _file_object
#     print("output will be sent to file: {0}".format(file))
#     print("restore to normal by calling 'mio.restore_output()'")
#     _file_object = open(file, 'w')
#     sys.stdout = _file_object
# 
# def restore_output():
#     """restore_output(): restore the standard output back to the
#              default (also closes the capture file)"""
#     global _file_object
#     sys.stdout = sys.__stdout__
#     _file_object.close()
#     print("standard output has been restored back to normal")
# 
# def print_file(file="capture_file.txt"):
#     """print_file(file="capture_file.txt"): print the given file to the
#          standard output"""
#     f = open(file, 'r')
#     print(f.read())
#     f.close()
# 
# def clear_file(file="capture_file.txt"):
#     """clear_file(file="capture_file.txt"): clears the contents of the
#          given file"""
#     f = open(file, 'w')
#     f.close()
#

"""### Try This: Redirecting output

Write some code to use the `mio.py` module in listing 13.1 to capture all the print output of a script to a file named `myfile.txt`, reset the standard output to the screen, and print that file to screen.

**Note:** This will not work with Colaboratory or Jupyter notebooks unless you write the code for `mio.py` and your test code to Python files, and then execute your file using the ! prefix. The cell above that will write `mio.py` to a Python file.
"""



# @title
# mio_test.py

import mio

def main():
    mio.capture_output("myfile.txt")
    print("hello")
    print(1 + 3)
    mio.restore_output()

    mio.print_file("myfile.txt")


if __name__ == '__main__':
    main()

"""# 13.7 Handling structured binary data with the struct module"""

import struct
record_format = 'hd7s'
data_record = struct.pack(record_format, 42, 3.14, b'goodbye')
with open("data", "wb") as data_file:
    data_file.write(data_record)

data_record

import struct

record_format = 'hd7s'
record_size = struct.calcsize(record_format)
result_list = []
with open("data", 'rb') as input:
    while True:
        record = input.read(record_size)  #A
        if not record:  #B
            break
        result_list.append(struct.unpack(record_format, record))  #C

print(result_list)

"""# 13.8 Pickling objects to files"""

import pickle
a = 42
b = 3.14
c = "test"
file = open("state", 'wb')
pickle.dump(a, file)
pickle.dump(b, file)
pickle.dump(c, file)
file.close()

import pickle
file = open("state", 'rb')
a = pickle.load(file)
b = pickle.load(file)
c = pickle.load(file)
file.close()
print(f"{a=} {b=} {c=}")

import pickle

def save_data(data_dict):
    with open("state", 'wb') as file:
        pickle.dump(data_dict, file)

def restore_data():
    with open("state", 'rb') as file:
        data_dict = pickle.load(file)
    return data_dict

if __name__ == '__main__':
    data_dict = {'a': 42,
                'b': 3.14,
                'c': "test"
                }
    save_data(data_dict)
    restored_data = restore_data()
    print(restored_data)

"""### Listing 13.2 File sole.py"""

"""sole module: contains functions sole, save, show"""
import pickle
_sole_mem_cache_d = {}
_sole_disk_file_s = "solecache"
file = open(_sole_disk_file_s, 'rb')          #A
_sole_mem_cache_d = pickle.load(file)
file.close()

def sole(m, n, t):                            #B
    """sole(m, n, t): perform the sole calculation using the cache."""
    global _sole_mem_cache_d
    if (m, n, t) in _sole_mem_cache_d:
        return _sole_mem_cache_d[(m, n, t)]
    else:
        # . . . do some time-consuming calculations . . .
        result = f"{m=}, {n=}, {t=}"   #C
        _sole_mem_cache_d[(m, n, t)] = result
        return result

def save():
    """save(): save the updated cache to disk."""
    global _sole_mem_cache_d, _sole_disk_file_s
    file = open(_sole_disk_file_s, 'wb')
    pickle.dump(_sole_mem_cache_d, file)
    file.close()

def show():
    """show(): print the cache"""
    global _sole_mem_cache_d
    print(_sole_mem_cache_d)

# TO CREATE CACHE FILE - execute before using above

import pickle
file = open("solecache",'wb')
pickle.dump({}, file)
file.close()

# Experiments with sole.py
sole(1, 2, 3)
sole(11, 22, 33)
show()
save()

"""# 13.9 Shelving objects"""

import shelve
book = shelve.open("addresses")

book['flintstone'] = ('fred', '555-1234', '1233 Bedrock Place')
book['rubble'] = ('barney', '555-4321', '1235 Bedrock Place')

book.close()

import shelve
book = shelve.open("addresses")

book['flintstone']

"""# Lab 13: Final fixes to wc
One thing that the wc utilty can do that our current Python version can't is handle input redirection, which is common particularly in Linux/Unix commandline environements. Refactor your existing Python version to handle redirection. That is, if a file is given as a command line argument, the utility should read from and process that file, but if no file argument is given, it should read from and process `stdin`.  For example with a file name:
```
! python wc_redirect.py wc_redirect.py   #A
```
```
62  182 2058 wc_redirect.py
```
With redirection (no file name):
```
! python wc_redirect.py < wc_redirect.py  #B
```
```
 62  182 2058
```

HINT: if you use the argparse library you need to be able to handle both having and not having an argument for the input filename, since if the input is coming via redirection argparse will not have a filename. To deal with this, look at the argparse documentation for `nargs` at https://docs.python.org/3/library/argparse.html#nargs and particularly the `?` options.

## Author's solution

Execute cell below to save to file `wc_redirect.py`.
"""

# @title
open("wc_redirect.py", "w").write('''#!/usr/bin/env python3
# File: wc_redirect.py
""" Reads a file and returns the number of lines, words,
    and characters - similar to the UNIX wc utility
"""
import sys
import argparse


def main():
    # initialze counts
    line_count = 0
    word_count = 0
    char_count = 0
    byte_count = 0
    longest_line = 0

    parser = argparse.ArgumentParser(usage=__doc__)
    parser.add_argument("-c", "--chars",
                  action="store_true", dest="chars", default=False,
                  help="display number of characters")
    parser.add_argument("-w", "--words",
                  action="store_true", dest="words", default=False,
                  help="display number of words")
    parser.add_argument("-l", "--lines",
                  action="store_true", dest="lines", default=False,
                  help="display number of lines")
    parser.add_argument("-L", "--longest",
                  action="store_true", dest="longest", default=False,
                  help="display longest line length")
    parser.add_argument("file", nargs='?', type=argparse.FileType('r'), #A
                        default=sys.stdin,   #B
                        help="read data from this file")
    args = parser.parse_args()

    with  args.file  as infile:
        for line in infile.readlines():   #C
            line_count += 1
            char_count += len(line)
            words = line.split()
            word_count += len(words)
            if len(line) > longest_line:
                longest_line = len(line)

    default_args = any([getattr(args, _) for _ in ('chars', 'words', 'lines', 'longest')])

    if not default_args:
        args.chars = args.lines = args.words = True

    if args.lines:
        print(f"{line_count:3}", end=" ")
    if args.words:
        print(f"{word_count:4}", end=" ")
    if args.chars:
        print(f"{char_count:4}", end=" ")
    if args.longest:
        print(f'{longest_line}', end=" ")
    if args.file.name != '<stdin>':      #D
        print(f'{args.file.name}', end=" ")
    print()

if __name__ == '__main__':
    main()
    ''')

#!/usr/bin/env python3
# File: wc_redirect.py
""" Reads a file and returns the number of lines, words,
    and characters - similar to the UNIX wc utility
"""
import sys
import argparse


def main():
    # initialze counts
    line_count = 0
    word_count = 0
    char_count = 0
    byte_count = 0
    longest_line = 0

    parser = argparse.ArgumentParser(usage=__doc__)
    parser.add_argument("-c", "--chars",
                  action="store_true", dest="chars", default=False,
                  help="display number of characters")
    parser.add_argument("-w", "--words",
                  action="store_true", dest="words", default=False,
                  help="display number of words")
    parser.add_argument("-l", "--lines",
                  action="store_true", dest="lines", default=False,
                  help="display number of lines")
    parser.add_argument("-L", "--longest",
                  action="store_true", dest="longest", default=False,
                  help="display longest line length")
    parser.add_argument("file", nargs='?', type=argparse.FileType('r'), #A
                        default=sys.stdin,   #B
                        help="read data from this file")
    args = parser.parse_args()

    with  args.file  as infile:
        for line in infile.readlines():   #C
            line_count += 1
            char_count += len(line)
            words = line.split()
            word_count += len(words)
            if len(line) > longest_line:
                longest_line = len(line)

    default_args = any([getattr(args, _) for _ in ('chars', 'words', 'lines', 'longest')])

    if not default_args:
        args.chars = args.lines = args.words = True

    if args.lines:
        print(f"{line_count:3}", end=" ")
    if args.words:
        print(f"{word_count:4}", end=" ")
    if args.chars:
        print(f"{char_count:4}", end=" ")
    if args.longest:
        print(f'{longest_line}', end=" ")
    if args.file.name != '<stdin>':      #D
        print(f'{args.file.name}', end=" ")
    print()

if __name__ == '__main__':
    main()

! python wc_redirect.py -l -w -c -L < wc_redirect.py

"""## Copilot's solution

### Prompt:

Refactor the current file `wc_coplilot.py` to make the script support input/output redirection. Output should be similar to that of `wc` utility.

Execute cell below to save `wc_redirect_copilot.py` to disk.
"""

# @title
open("wc_redirect_copilot.py", "w").write("""# wc_copilot.py

import argparse
import sys

def count_stats(file):
    lines = file.readlines()

    line_count = len(lines)
    word_count = sum(len(line.split()) for line in lines)
    char_count = sum(len(line) for line in lines)
    max_line_length = max(len(line) for line in lines)

    return line_count, word_count, char_count, max_line_length

def main():
    parser = argparse.ArgumentParser(description='Count lines, words, and characters in a file.')
    parser.add_argument('file', nargs='?', type=argparse.FileType('r'), #A
                         default=sys.stdin, help='File to count')
    parser.add_argument('-l', '--lines', action='store_true', help='Count lines')
    parser.add_argument('-w', '--words', action='store_true', help='Count words')
    parser.add_argument('-c', '--chars', action='store_true', help='Count characters')
    parser.add_argument('-L', '--max-line-length', action='store_true', help='Print length of the longest line')
    args = parser.parse_args()

    line_count, word_count, char_count, max_line_length = count_stats(args.file)

    output = []
    if args.lines:
        output.append(str(line_count))
    if args.words:
        output.append(str(word_count))
    if args.chars:
        output.append(str(char_count))
    if args.max_line_length:
        output.append(str(max_line_length))

    print(' '.join(output))

if __name__ == '__main__':
    main()
""")

# wc_redirect_copilot.py

import argparse
import sys

def count_stats(file):
    lines = file.readlines()

    line_count = len(lines)
    word_count = sum(len(line.split()) for line in lines)
    char_count = sum(len(line) for line in lines)
    max_line_length = max(len(line) for line in lines)

    return line_count, word_count, char_count, max_line_length

def main():
    parser = argparse.ArgumentParser(description='Count lines, words, and characters in a file.')
    parser.add_argument('file', nargs='?', type=argparse.FileType('r'), #A
                         default=sys.stdin, help='File to count')
    parser.add_argument('-l', '--lines', action='store_true', help='Count lines')
    parser.add_argument('-w', '--words', action='store_true', help='Count words')
    parser.add_argument('-c', '--chars', action='store_true', help='Count characters')
    parser.add_argument('-L', '--max-line-length', action='store_true', help='Print length of the longest line')
    args = parser.parse_args()

    line_count, word_count, char_count, max_line_length = count_stats(args.file)

    output = []
    if args.lines:
        output.append(str(line_count))
    if args.words:
        output.append(str(word_count))
    if args.chars:
        output.append(str(char_count))
    if args.max_line_length:
        output.append(str(max_line_length))

    print(' '.join(output))

if __name__ == '__main__':
    main()

! python wc_redirect_copilot.py -l -w -c -L wc_redirect_copilot.py

"""## Colaboratory's solution

### Prompt:

Refactor the cell above to make the script support input/output
redirection. Output should be similar to that of wc utility.


Execute cell below to save `wc_redirect_colab.py` to disk.
"""

# @title
open("wc_redirect_colab.py", "w").write('''# prompt: Refactor the cell above to make the script support input/output
#         redirection. Output should be similar to that of wc utility.

import argparse
import sys

""" Reads a file and returns the number of lines, words,
    and characters - similar to the UNIX wc utility
"""


def main():
    parser = argparse.ArgumentParser(usage=__doc__)
    parser.add_argument("filename", nargs='*')   #A
    parser.add_argument("-l", "--lines", dest="lines",
                      action='store_true', default=False,
                      help="Show only line count")
    parser.add_argument("-w", "--words", dest="words",
                      action='store_true', default=False,
                      help="Show only word count")
    parser.add_argument("-c", "--chars", dest="chars",
                      action='store_true', default=False,
                      help="Show only character count")
    parser.add_argument("-L", "--longest", dest="longest",
                      action='store_true', default=False,
                      help="Show length of longest line")
    args = parser.parse_args()

    if not sys.stdin.isatty():    #B
        # Read from standard input
        lines = sys.stdin.readlines()
    else:
        for filename in args.filename:  #C
            with open(filename) as infile:
                lines = infile.readlines()

    line_count = len(lines)
    word_count = sum(len(line.split()) for line in lines)
    char_count = sum(len(line) for line in lines)
    longest_line_length = max(len(line) for line in lines)

    if args.lines:
        print(f"{line_count}")
    elif args.words:
        print(f"{word_count}")
    elif args.chars:
        print(f"{char_count}")
    elif args.longest:
        print(f"{longest_line_length}")
    else:
        print(f"{line_count} {word_count} {char_count}")

if __name__ == '__main__':
    main()
    ''')

# prompt: Refactor the cell above to make the script support input/output
#         redirection. Output should be similar to that of wc utility.

import argparse
import sys

""" Reads a file and returns the number of lines, words,
    and characters - similar to the UNIX wc utility
"""


def main():
    parser = argparse.ArgumentParser(usage=__doc__)
    parser.add_argument("filename", nargs='*')   #A
    parser.add_argument("-l", "--lines", dest="lines",
                      action='store_true', default=False,
                      help="Show only line count")
    parser.add_argument("-w", "--words", dest="words",
                      action='store_true', default=False,
                      help="Show only word count")
    parser.add_argument("-c", "--chars", dest="chars",
                      action='store_true', default=False,
                      help="Show only character count")
    parser.add_argument("-L", "--longest", dest="longest",
                      action='store_true', default=False,
                      help="Show length of longest line")
    args = parser.parse_args()

    if not sys.stdin.isatty():    #B
        # Read from standard input
        lines = sys.stdin.readlines()
    else:
        for filename in args.filename:  #C
            with open(filename) as infile:
                lines = infile.readlines()

    line_count = len(lines)
    word_count = sum(len(line.split()) for line in lines)
    char_count = sum(len(line) for line in lines)
    longest_line_length = max(len(line) for line in lines)

    if args.lines:
        print(f"{line_count}")
    elif args.words:
        print(f"{word_count}")
    elif args.chars:
        print(f"{char_count}")
    elif args.longest:
        print(f"{longest_line_length}")
    else:
        print(f"{line_count} {word_count} {char_count}")

if __name__ == '__main__':
    main()

! python wc_redirect_colab.py -l -w -c -L < wc_redirect_colab.py