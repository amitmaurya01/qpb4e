# -*- coding: utf-8 -*-
"""Chapter_14.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/github/nceder/qpb4e/blob/main/code/Chapter%2014/Chapter_14.ipynb

# 14 Exceptions

### Python built-in exceptions

```python
BaseException
    BaseExceptionGroup
    GeneratorExit
    KeyboardInterrupt
    SystemExit
    Exception
        ArithmeticError
            FloatingPointError
            OverflowError
            ZeroDivisionError
        AssertionError
        AttributeError
        BufferError
        EOFError
        ExceptionGroup [BaseExceptionGroup]
        ImportError
            ModuleNotFoundError
        LookupError
            IndexError
            KeyError
        MemoryError
        NameError
            UnboundLocalError
        OSError
            BlockingIOError
            ChildProcessError
            ConnectionError
                BrokenPipeError
                ConnectionAbortedError
                ConnectionRefusedError
                ConnectionResetError
            FileExistsError
            FileNotFoundError
            InterruptedError
            IsADirectoryError
            NotADirectoryError
            PermissionError
            ProcessLookupError
            TimeoutError
        ReferenceError
        RuntimeError
            NotImplementedError
            PythonFinalizationError
            RecursionError
        StopAsyncIteration
        StopIteration
        SyntaxError
            IncompleteInputError
            IndentationError
                TabError
        SystemError
        TypeError
        ValueError
            UnicodeError
                UnicodeDecodeError
                UnicodeEncodeError
                UnicodeTranslateError
        Warning
            BytesWarning
            DeprecationWarning
            EncodingWarning
            FutureWarning
            ImportWarning
            PendingDeprecationWarning
            ResourceWarning
            RuntimeWarning
            SyntaxWarning
            UnicodeWarning
            UserWarning
```

## 14.2.2 Raising exceptions
"""

alist = [1, 2, 3]
element = alist[7]

raise IndexError("Just kidding")

"""### Try This: Catching exceptions

Write code that gets two numbers from the user and divides the first number by the second. Check for and catch the exception that occurs if the second number is zero (`ZeroDivisionError`).

The code of your program should do the following:
```
Please enter an integer: 1
Please enter another integer: 0
Can't divide by zero.
```
"""



# @title
x = int(input("Please enter an integer: "))
y = int(input("Please enter another integer: "))

try:
    z = x / y
    print(z)
except ZeroDivisionError as e:
    print("Can't divide by zero.")

"""## 14.2.4 Defining new exceptions"""

class MyError(Exception):
    pass

raise MyError("Some information about what went wrong")

try:
    raise MyError("Some information about what went wrong")
except MyError as error:
    print("Situation:", error)

try:
    raise MyError("Some information", "my_filename", 3)
except MyError as error:
    print("Situation: {0} with file {1}\n error code: {2}".format(
        error.args[0],
 error.args[1], error.args[2]))

"""## 14.2.5 Exception groups

"""

import sys
if sys.version_info.minor < 11:
  raise RuntimeError(f"Python version must be >= 3.11 to use exception groups, current version is {sys.version}")

"""**This will not run (will raise a SyntaxError) on Python versions before. 3.11**"""

try:
    raise ExceptionGroup("Multiple exceptions",[TypeError(),  #A
                          FileNotFoundError(), ValueError()])
except* TypeError:    #B
    message += f"Handling TypeError\n"
except* IOError: #C
    message += f"Handling IOError\n"
except* ValueError:   #D
    message += f"Handling ValueError\n"
finally:
    print(message)

"""## 14.2.6 Debugging programs with the assert statement"""

x = (1, 2, 3)
assert len(x) > 5, "len(x) not > 5"

"""### Try This: The assert statement

Write a simple program that gets a number from the user and then uses the assert statement to raise an exception if the number is zero. Test to make sure that the assert statement fires; then turn it off, using one of the methods mentioned in this section.


"""



# @title
x = int(input("Please enter a non-zero integer: "))

assert x != 0, "Integer can not be zero."

"""## 14.2.9 Example: exceptions in normal evaluation"""

def cell_value(string):
    try:
        return float(string)
    except ValueError:
        if string == "":
            return 0
        else:
            return None

def safe_apply(function, x, y, spreadsheet):
    try:
        return function(x, y, spreadsheet)
    except TypeError:
        return None

"""### Try This: Exceptions
What code would you use to create a custom `ValueTooLarge` exception and raise that exception if the variable `x` is over 1000?
"""



# @title
class ValueTooLarge(Exception):
    pass

x = 1001
if x > 1000:
    raise ValueTooLarge()

"""# 14.3 Context managers using the `with` keyword"""

! touch empty.txt
filename = "empty.txt"
try:
    infile = open(filename)
    data = infile.read()
finally:
    infile.close()

with open(filename) as infile:
    data = infile.read()

with open("empty.txt") as infile, open("other.txt", "w") as outfile:
    data = infile.read()
    outfile.write(data)

with (
    open("empty.txt") as infile,
    open("other.txt", "w") as outfile
):
    data = infile.read()
    outfile.write(data)

"""# 14.4 Custom exceptions

Think about the module you wrote in chapter 9 to count word frequencies. What errors might reasonably occur in those functions? Refactor those functions to handle those exception conditions appropriately.

### Author's solution
"""

!wget https://raw.githubusercontent.com/nceder/qpb4e/main/code/Chapter%2006/moby_01.txt &> /dev/null  && echo Downloaded

# Author's version
import string
punct = str.maketrans('', '', string.punctuation)

class EmptyStringError(Exception):
    pass
def clean_line(line):
    """changes case and removes punctuation"""

    # raise exception if line is empty
    # Comment out/remove two lines below to ignore EmptyStringError condition
    if not line.strip():
        raise EmptyStringError()
    # make all one case
    cleaned_line = line.lower()

    # remove punctuation
    cleaned_line = cleaned_line.translate(punct)
    return cleaned_line


def count_words(words):
    """takes list of cleaned words, returns count dictionary"""
    word_count = {}
    for word in words:
        try:
            count = word_count.setdefault(word, 0)
        except TypeError:
            #if 'word' is not hashable, skip to next word.
            pass
        word_count[word] += 1
    return word_count

def word_stats(word_count):
    """Takes word count dictionary and returns top, bottom five entries"""
    word_list = list(word_count.items())
    try:
        word_list.sort(key=lambda x: x[1])
    except TypeError as e:
        print(f"Error sorting word list: {e}")

    least_common = word_list[:5]
    most_common = word_list[-1:-6:-1]

    return most_common, least_common

def get_words(line):
    """splits line into words, and rejoins with newlines"""
    words = line.split()
    return "\n".join(words) + "\n"

def clean_file(filename, outfilename):
    try:
        with open(filename) as infile, open(outfilename, "w") as outfile:
            for line in infile:
                if line.strip():
                    cleaned_line = clean_line(line)

                    cleaned_words = get_words(cleaned_line)

                    # write all words for line
                    outfile.write(cleaned_words)
    except IOError as e:
        print(f"Error reading or writing to file: {e}")

def load_words(cleaned_filename):
    words = []
    print(cleaned_filename)
    try:
        with open(cleaned_filename) as infile:
            for word in infile:
                if word.strip():
                    words.append(word.strip())
    except IOError as e:
        print(f"Error reading or writing to file: {e}")
    return words

clean_file("moby_01.txt", "moby_clean.txt")
moby_words = load_words("moby_clean.txt")
word_count = count_words(moby_words)

most, least = word_stats(word_count)
print("Most common words:")
for word in most:
    print(word)
print("\nLeast common words:")
for word in least:
    print(word)

"""### Original Copilot code"""

# Generated by Copilot
import string

def clean_line(line):
    # Convert the line to lowercase
    line = line.lower()

    # Remove punctuation from the line
    line = line.translate(str.maketrans('', '', string.punctuation))

    return line

def write_words_to_file(words, output_file):
    # Write each word to the output file
    for word in words:
        output_file.write(word + '\n')

def count_word_occurrences(words):
    # Count the occurrences of each word using a dictionary
    word_counts = {}
    for word in words:
        if word in word_counts:
            word_counts[word] += 1
        else:
            word_counts[word] = 1

    return word_counts

def print_common_words(word_counts, n):
    # Sort the word counts in descending order
    sorted_word_counts = sorted(word_counts.items(), key=lambda x: x[1], reverse=True)

    # Print the n most common words and their occurrences
    print(f"{n} most common words:")
    for word, count in sorted_word_counts[:n]:
        print(f"{word}: {count}")

def print_least_common_words(word_counts, n):
    # Sort the word counts in descending order
    sorted_word_counts = sorted(word_counts.items(), key=lambda x: x[1], reverse=True)

    # Print the n least common words and their occurrences
    print(f"{n} least common words:")
    for word, count in sorted_word_counts[-n:]:
        print(f"{word}: {count}")

def process_file(input_file_path, output_file_path):
    # Open the input file for reading
    with open(input_file_path, 'r') as input_file:
        # Open the output file for writing
        with open(output_file_path, 'w') as output_file:
            # Iterate over each line in the input file
            for line in input_file:
                # Clean the line
                cleaned_line = clean_line(line)

                # Split the line into words
                words = cleaned_line.split()

                # Write the words to the output file
                write_words_to_file(words, output_file)

def main():
    input_file_path = 'moby_01.txt'
    output_file_path = 'moby_01_clean.txt'

    # Process the file
    process_file(input_file_path, output_file_path)

    # Open the file
    with open(output_file_path, 'r') as file:
        # Read the file content
        content = file.read()

    # Split the content into words
    words = content.split()

    # Count word occurrences
    word_counts = count_word_occurrences(words)

    # Print the five most common words and their occurrences
    print_common_words(word_counts, 5)

    # Print the five least common words and their occurrences
    print_least_common_words(word_counts, 5)

if __name__ == "__main__":
    main()

"""### New refactored code from Copilot"""

# Generated by Copilot
import string
def clean_line(line):
    # Convert the line to lowercase
    line = line.lower()

    # Remove punctuation from the line
    line = line.translate(str.maketrans('', '', string.punctuation))

    return line

#=== Refactored code to add exception handling===========
def write_words_to_file(words, output_file):
    try:
        for word in words:
            output_file.write(word + '\n')
    except IOError as e:
        print(f"Error writing to file: {e}")

def count_word_occurrences(words):
    if not hasattr(words, '__iter__'):
        raise TypeError("Input must be iterable")

    word_counts = {}
    for word in words:
        if word in word_counts:
            word_counts[word] += 1
        else:
            word_counts[word] = 1

    return word_counts

def print_common_words(word_counts, n):
    if not isinstance(n, int) or n <= 0:
        raise ValueError("n must be a positive integer")

    sorted_word_counts = sorted(word_counts.items(), key=lambda x: x[1], reverse=True)

    print(f"{n} most common words:")
    try:
        for word, count in sorted_word_counts[:n]:
            print(f"{word}: {count}")
    except IndexError as e:
        print(f"Less than {n} words in input: {e}")

def print_least_common_words(word_counts, n):
    if not isinstance(n, int) or n <= 0:
        raise ValueError("n must be a positive integer")

    sorted_word_counts = sorted(word_counts.items(), key=lambda x: x[1])

    print(f"{n} least common words:")
    try:
        for word, count in sorted_word_counts[:n]:
            print(f"{word}: {count}")
    except IndexError as e:
        print(f"Less than {n} words in input: {e}")

#=== End of refactored code to add exception handling===========

def process_file(input_file_path, output_file_path):
    # Open the input file for reading
    with open(input_file_path, 'r') as input_file:
        # Open the output file for writing
        with open(output_file_path, 'w') as output_file:
            # Iterate over each line in the input file
            for line in input_file:
                # Clean the line
                cleaned_line = clean_line(line)

                # Split the line into words
                words = cleaned_line.split()

                # Write the words to the output file
                write_words_to_file(words, output_file)

def main():
    input_file_path = 'moby_01.txt'
    output_file_path = 'moby_01_clean.txt'

    # Process the file
    process_file(input_file_path, output_file_path)

    # Open the file
    with open(output_file_path, 'r') as file:
        # Read the file content
        content = file.read()

    # Split the content into words
    words = content.split()

    # Count word occurrences
    word_counts = count_word_occurrences(words)

    # Print the five most common words and their occurrences
    print_common_words(word_counts, 5)

    # Print the five least common words and their occurrences
    print_least_common_words(word_counts, 5)

if __name__ == "__main__":
    main()

"""### Original Colaboratory code"""

# Generated by Colaboratory
# prompt: Refactor the code in the previous 2 cells into functions for cleaning
#         and processing the data.  The goal should be that most of the logic is
#         moved into functions.

# Function to clean a line of text by converting it to lowercase and removing punctuation
def clean_line(line):
  line = line.lower()
  line = line.translate(str.maketrans('', '', string.punctuation))
  return line

# Function to split a line of text into words and write each word to a new line in a file
def write_words_to_file(line, output_file):
  words = line.split()
  for word in words:
    output_file.write(word + '\n')

# Function to count the occurrences of each word in a list of words
def count_word_occurrences(words):
  word_counts = {}
  for word in words:
    if word not in word_counts:
      word_counts[word] = 0
    word_counts[word] += 1
  return word_counts

# Function to find the most and least common words in a dictionary of word counts
def find_most_and_least_common_words(word_counts):
  most_common = sorted(word_counts.items(), key=lambda item: item[1], reverse=True)[:5]
  least_common = sorted(word_counts.items(), key=lambda item: item[1])[:5]
  return most_common, least_common

# Open the input file for reading
with open('moby_01.txt', 'r') as input_file:
  # Open the output file for writing
  with open('moby_01_clean.txt', 'w') as output_file:
    # Iterate over each line in the input file
    for line in input_file:
      # Clean the line of text
      cleaned_line = clean_line(line)

      # Write each word in the clean line to the output file
      write_words_to_file(cleaned_line, output_file)

# Open the file and read the text into a variable.
with open('moby_01_clean.txt', 'r') as f:
  text = f.read()

# Split the text into words.
words = text.split()

# Count the occurrences of each word.
word_counts = count_word_occurrences(words)

# Find the most and least common words.
most_common, least_common = find_most_and_least_common_words(word_counts)

# Print the results.
print("Most common words:")
for word, count in most_common:
  print(f"{word}: {count}")

print("\nLeast common words:")
for word, count in least_common:
  print(f"{word}: {count}")

"""### Colaboratory reactored code with exception handling

"""

# prompt: Refactor the code in the cell above to handle errors that might
#         reasonably occur in those functions appropriately.
import string
# Function to clean a line of text by converting it to lowercase
# and removing punctuation
def clean_line(line):
  try:
    line = line.lower()
    line = line.translate(str.maketrans('', '', string.punctuation))
  except Exception as e:
    raise Exception("Error cleaning line: {}".format(e))
  return line

# Function to split a line of text into words and write each word to a new line in a file
def write_words_to_file(line, output_file):
  try:
    words = line.split()
    for word in words:
      output_file.write(word + '\n')
  except Exception as e:
    raise Exception("Error writing words to file: {}".format(e))

# Function to count the occurrences of each word in a list of words
def count_word_occurrences(words):
  word_counts = {}
  for word in words:
    try:
      if word not in word_counts:
        word_counts[word] = 0
      word_counts[word] += 1
    except Exception as e:
      raise Exception("Error counting word occurrences: {}".format(e))
  return word_counts

# Function to find the most and least common words in a dictionary of word counts
def find_most_and_least_common_words(word_counts):
  try:
    most_common = sorted(word_counts.items(), key=lambda item: item[1], reverse=True)[:5]
    least_common = sorted(word_counts.items(), key=lambda item: item[1])[:5]
  except Exception as e:
    raise Exception("Error finding most and least common words: {}".format(e))
  return most_common, least_common

# Open the input file for reading
with open('moby_01.txt', 'r') as input_file:
  # Open the output file for writing
  with open('moby_01_clean.txt', 'w') as output_file:
    # Iterate over each line in the input file
    for line in input_file:
      # Clean the line of text
      try:
        cleaned_line = clean_line(line)
      except Exception as e:
        print("Error cleaning line: {}".format(e))
        continue

      # Write each word in the clean line to the output file
      try:
        write_words_to_file(cleaned_line, output_file)
      except Exception as e:
        print("Error writing words to file: {}".format(e))
        continue

# Open the file and read the text into a variable.
try:
  with open('moby_01_clean.txt', 'r') as f:
    text = f.read()
except Exception as e:
  raise Exception("Error opening file: {}".format(e))

# Split the text into words.
try:
  words = text.split()
except Exception as e:
  raise Exception("Error splitting text into words: {}".format(e))

# Count the occurrences of each word.
try:
  word_counts = count_word_occurrences(words)
except Exception as e:
  raise Exception("Error counting word occurrences: {}".format(e))

# Find the most and least common words.
try:
  most_common, least_common = find_most_and_least_common_words(word_counts)
except Exception as e:
  raise Exception("Error finding most and least common words: {}".format(e))

# Print the results.
print("Most common words:")
for word, count in most_common:
  print(f"{word}: {count}")

print("\nLeast common words:")
for word, count in least_common:
  print(f"{word}: {count}")