# -*- coding: utf-8 -*-
"""Chapter_15.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/github/nceder/qpb4e/blob/main/code/Chapter%2015/Chapter_15.ipynb

# 15 Classes and object-oriented programming

## 15.1.1 Using a class instance as a structure or record
"""

class Circle:
    pass

my_circle = Circle()
my_circle.radius = 5
print(2 * 3.14 * my_circle.radius)

class Circle:
    def __init__(self):          #A
        self.radius = 1
my_circle = Circle()                  #B
print(2 * 3.14 * my_circle.radius)    #C

my_circle.radius = 5                 #D
print(2 * 3.14 * my_circle.radius)   #E

"""# 15.2 Instance variables"""

class Circle:
    def __init__(self):
        self.radius = 1

"""### Try This: Instance Variables

What code would you use to create a Rectangle class?
"""



# @title
class Rectangle:
    def __init__(self, height, width):
        self.height = height
        self.width = width

"""## 15.3 Methods"""

class Circle:
    def __init__(self):
        self.radius = 1
    def area(self):
        return self.radius * self.radius * 3.14159

c = Circle()
c.radius = 3
print(c.area())

print(Circle.area(c))

class Circle:
    def __init__(self, radius):
        self.radius = radius
    def area(self):
        return self.radius * self.radius * 3.14159

"""### Try This: Instance variables and Methods

Update the code for a `Rectangle` class so that you can set the dimensions when an instance is created, just as for the `Circle` class above. Also, add an `area()` method.
"""



# @title
class Rectangle:
    def __init__(self, height, width):
        self.height = height
        self.width = width

    def area(self):
        return self.height * self.width

"""# 15.4 Class variables"""

class Circle:
    pi = 3.14159
    def __init__(self, radius):
        self.radius = radius
    def area(self):
        return self.radius * self.radius * Circle.pi

Circle.pi

Circle.pi = 4
Circle.pi

Circle.pi = 3.14159
Circle.pi

c = Circle(3)
c.area()

print(Circle)

print(c.__class__)

c.__class__.pi

"""## 15.4.1 An oddity with class variables"""

c = Circle(3)
c.pi

c1 = Circle(1)
c2 = Circle(2)
c1.pi = 3.14
c1.pi

c2.pi

Circle.pi

"""### Listing 15.1 File circle.py"""

!wget https://raw.githubusercontent.com/nceder/qpb4e/main/code/Chapter%2015/circle.py &> /dev/null  && echo Downloaded

"""circle module: contains the Circle class."""
class Circle:
    """Circle class"""
    all_circles = []             #A
    pi = 3.14159
    def __init__(self, r=1):
        """Create a Circle with the given radius"""
        self.radius = r
        self.__class__.all_circles.append(self)   #B
    def area(self):
        """determine the area of the Circle"""
        return self.__class__.pi * self.radius * self.radius

    @staticmethod
    def total_area():
        """Static method to total the areas of all Circles """
        total = 0
        for c in Circle.all_circles:
            total = total + c.area()
        return total

import circle
c1 = circle.Circle(1)
c2 = circle.Circle(2)
circle.Circle.total_area()

c2.radius = 3
circle.Circle.total_area()

circle.__doc__

circle.Circle.__doc__

circle.Circle.area.__doc__

"""## 15.5.2 Class methods"""

!wget https://raw.githubusercontent.com/nceder/qpb4e/main/code/Chapter%2015/circle_cm.py &> /dev/null  && echo Downloaded

"""### Listing 15.2 File circle_cm.py"""

"""circle_cm module: contains the Circle class."""
class Circle:
    """Circle class"""
    all_circles = []              #A
    pi = 3.14159
    def __init__(self, r=1):
        """Create a Circle with the given radius"""
        self.radius = r
        self.__class__.all_circles.append(self)
    def area(self):
        """determine the area of the Circle"""
        return self.__class__.pi * self.radius * self.radius

    @classmethod             #A
    def total_area(cls):              #B
        total = 0
        for c in cls.all_circles:          #C
            total = total + c.area()
        return total

import circle_cm
c1 = circle_cm.Circle(1)
c2 = circle_cm.Circle(2)
circle_cm.Circle.total_area()

c2.radius = 3
circle_cm.Circle.total_area()

"""### Try This: Class methods

Write a class method similar to `total_area()` that returns the total circumference of all circles.
"""



# @title
class Circle:
    pi = 3.14159
    all_circles = []
    def __init__(self, radius):
        self.radius = radius
        self.__class__.all_circles.append(self)

    def area(self):
        return self.radius * self.radius * Circle.pi

    def circumference(self):
        return 2 * self.radius * Circle.pi

    @classmethod
    def total_circumference(cls):
        """class method to total the circumference of all Circles """
        total = 0
        for c in cls.all_circles:
            total = total + c.circumference()
        return total

"""# 15.6 Inheritance"""

class Square:
    def __init__(self, side=1):
        self.side = side                     #A

class Square:
    def __init__(self, side=1, x=0, y=0):
        self.side = side
        self.x = x
        self.y = y
class Circle:
    def __init__(self, radius=1, x=0, y=0):
        self.radius = radius
        self.x = x
        self.y = y

class Shape:
    def __init__(self, x, y):
        self.x = x
        self.y = y
class Square(Shape):                                #A
    def __init__(self, side=1, x=0, y=0):
        super().__init__(x, y)                      #B
        self.side = side
class Circle(Shape):                                #C
    def __init__(self, r=1, x=0, y=0):
        super().__init__(x, y)            #B
        self.radius = r

class Shape:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    def move(self, delta_x, delta_y):
        self.x = self.x + delta_x
        self.y = self.y + delta_y
class Square(Shape):
    def __init__(self, side=1, x=0, y=0):
        super().__init__(x, y)
        self.side = side
class Circle(Shape):
    def __init__(self, r=1, x=0, y=0):
        super().__init__(x, y)
        self.radius = r

c = Circle(1)
c.move(3, 4)
f"c.x = {c.x}, c.y = {c.y}"

"""### Try This: Inheritance

Rewrite the code for a `Rectangle` class to inherit from `Shape`. Because squares and rectangles are related, would it make sense to inherit one from the other? If so, which would be the base class, and which would inherit?

How would you write the code to add an `area()` method for the `Square` class? Should the `area` method be moved into the base `Shape` class and inherited by `Circle`, `Square`, and `Rectangle`? If so, what issues would result?
"""



# @title
class Shape:
    def __init__(self, x, y):
        self.x = x
        self.y = y

class Rectangle(Shape):
    def __init__(self, x, y):
        super().__init__(x, y)

"""# 15.7 Inheritance with class and instance variables"""

class P:
    z = "Hello"
    def set_p(self):
        self.x = "Class P"
    def print_p(self):
         print(self.x)
class C(P):
    def set_c(self):
        self.x = "Class C"
    def print_c(self):
        print(self.x)

c = C()
c.set_p()
c.print_p()

c.print_c()

c.set_c()
c.print_c()

c.print_p()

f"{c.z=} {C.z=} {P.z=}"

C.z = "Bonjour"
f"{c.z=} {C.z=} {P.z=}"

c.z = "Ciao"
f"{c.z=} {C.z=} {P.z=}"

"""# 15.8 Recap: Basics of Python classes"""

class Shape:
    def __init__(self, x, y):        #A
        self.x = x                 #B
        self.y = y                 #B
    def move(self, delta_x, delta_y):  #C
        self.x = self.x + delta_x    #D
        self.y = self.y + delta_y

class Circle(Shape):                                #A
    pi = 3.14159           #B
    all_circles = []       #B
    def __init__(self, r=1, x=0, y=0):                  #C
        super().__init__(x, y)   #D
        self.radius = r
        self.__class__.all_circles.append(self)     #E
    @classmethod       #F
    def total_area(cls):
        area = 0
        for circle in cls.all_circles:
            area += cls.circle_area(circle.radius)     #G
        return area
    @staticmethod
    def circle_area(radius):               #H
        return Circle.pi * radius * radius           #I

c1 = Circle()
c1.radius, c1.x, c1.y

c2 = Circle(2, 1, 1)
c2.radius, c2.x, c2.y

c2.move(2, 2)
c2.radius, c2.x, c2.y

Circle.all_circles

[c1, c2]

Circle.total_area()

c2.total_area()

Circle.circle_area(c1.radius)

c1.circle_area(c1.radius)

"""# 15.9 Private variables and private methods"""

class Mine:
    def __init__(self):
        self.x = 2
        self.__y = 3                    #A
    def print_y(self):
        print(self.__y)

m = Mine()

print(m.x)

print(m.__y)

m.print_y()

dir(m)

"""###Try This: Private instance variables

Modify the Rectangle class's code to make the dimension variables private. What restriction will this modification impose on using the class?

"""



# @title
class Rectangle():
    def __init__(self, x, y):
        self.__x = x
        self.__y = y

"""# 15.10 Using @property for more flexible instance variables"""

class Temperature:
    def __init__(self):
        self._temp_fahr = 0
    @property
    def temp(self):
        return (self._temp_fahr - 32) * 5 / 9

class Temperature:
    def __init__(self):
        self._temp_fahr = 0
    @property
    def temp(self):
        return (self._temp_fahr - 32) * 5 / 9
    @temp.setter
    def temp(self, new_temp):
        self._temp_fahr = new_temp * 9 / 5 + 32

t = Temperature()
t._temp_fahr

t.temp

t.temp = 34      #A
t._temp_fahr

t.temp     #B

"""### Try This: Properties

Update the dimensions of the Rectangle class to be properties with getters and setters that don't allow negative sizes.
"""



# @title
class Rectangle():
    def __init__(self, x, y):
        self.__x = x
        self.__y = y

    @property
    def x(self):
        return self.__x

    @x.setter
    def x(self, new_x):
        if new_x >= 0:
            self.__x = new_x

    @property
    def y(self):
        return self.__y

    @y.setter
    def y(self, new_y):
        if new_y >= 0:
            self.__y = new_y

# test
my_rect = Rectangle(1,2)
print(my_rect.x, my_rect.y)
my_rect.x = 4
my_rect.y = 5
print(my_rect.x, my_rect.y)

"""# 15.11 Scoping rules and namespaces for class instances

### Listing 15.3 File cs.py
"""

!wget https://raw.githubusercontent.com/nceder/qpb4e/main/code/Chapter%2015/cs.py &> /dev/null  && echo Downloaded

"""cs module: class scope demonstration module."""
mod_var ="module variable: mod_var"
def mod_func():
    return ("module level function: mod_func()")
class SuperClass:
    super_class_var = "superclass class variable: self.super_class_var"
    __priv_super_class_var = "private superclass class variable: no access"
    def __init__(self):
        self.super_instance_var = "superclass instance variable: self.super_instance_var "
        self.__psiv = "private superclass instance variable: no access"
    def super_class_method(self):
        return "superclass method: self.super_class_method()"
    def superclass_priv_method(self):
        return "superclass private method: no access"
class Class_(SuperClass):
    class_var = "class variable: self.class_var or Class_.class_var (for assignment)"
    __priv_class_var = "class private variable: self.__priv_class_var or Class_.__priv_class_var "
    def __init__(self):
        SuperClass.__init__(self)
        self.__priv_instance_var = "private instance variable: self.__priv_instance_var"
    def method_2(self):
        return "method: self.method_2()"
    def __priv_method(self):
        return "private method: self.__priv_method()"
    def method_1(self, param="parameter: param"):
        local_var = "local variable: local_var"
        self.instance_var = "instance variable: self.instance_var"
        print("Local")
        print("Access local, global and built-in namespaces directly")
        print("local namespace:", list(locals().keys()))
        print(param)                                               #A

        print(local_var)
        print()                                       #B
        print("global namespace:", list(globals().keys()))
        print(mod_var)                         #C

        print(mod_func())
        print()             #D
        print("Access instance, class, and superclass namespaces through 'self'")
        print("Instance namespace:", self.__dict__)

        print(self.instance_var)                                       #E

        print(self.__priv_instance_var)                    #F

        print(self.super_instance_var)                                         #G
        print("\nClass_ namespace:", Class_.__dict__)
        print(self.class_var)                                          #H

        print(self.method_2())                       #I

        print(self.__priv_class_var)                                   #J

        print(self.__priv_method())                            #K
        print("\nSuperclass namespace:", SuperClass.__dict__)
        print(self.super_class_method())                        #L

        print(self.super_class_var)                #M

#import cs
#c = cs.Class_()
#c.method_1()

c = Class_()
c.method_1()

"""# 15.14 Lab 15: HTML classes

In this lab, you create classes to represent an HTML document. To keep things simple, assume that each element can contain only text and one subelement. So the `<html>` element contains only a `<body>` element, and the `<body>` element contains (optional) text and a `<p>` element that contains only text.

The key feature to implement is the `__str__()` method, which in turn calls its subelement's `__str__()` method, so that the entire document is returned when the `str()` function is called on an `<html>` element. You can assume that any text comes before the subelement.

Here's example output from using the classes:
```python
para = p(text="this is some body text")
doc_body = body(text="This is the body", subelement=para)
doc = html(subelement=doc_body)
print(doc)
```
```html
<html>
<body>
This is the body
<p>
this is some body text
</p>
</body>
</html>
```

### Author's solution
"""

class element:
    def __init__(self, text=None, subelement=None):
        self.subelement = subelement
        self.text = text

    def __str__(self):
        value = f"<{self.__class__.__name__}>\n"
        if self.text:
            value += f"{self.text}\n"
        if self.subelement:
            value += str(self.subelement)
        value += f"</{self.__class__.__name__}>\n"
        return value

class html(element):
    pass

class body(element):
    pass

class p(element):
    pass

#test
para = p(text="this is some body text")
doc_body = body(text="This is the body", subelement=para)
doc = html(subelement=doc_body)
print(doc)

"""### Copilot solution"""

class Element:
    tag = ""

    def __init__(self, text="", subelement=None):
        self.text = text
        self.subelement = subelement

    def __str__(self):
        result = f"<{self.tag}>\n"
        if self.text:
            result += self.text + "\n"
        if self.subelement:
            result += str(self.subelement)
        result += f"</{self.tag}>\n"
        return result

class Html(Element):
    tag = "html"

class Body(Element):
    tag = "body"

class P(Element):
    tag = "p"

# Usage:
para = P(text="this is some body text")
doc_body = Body(text="This is the body", subelement=para)
doc = Html(subelement=doc_body)
print(doc)

"""### Colaboratory solution

(generated when immediately below problem statement)
"""

# prompt: Generate the code described in the cell above.

class html:
    def __init__(self, subelement):
        self.subelement = subelement
    def __str__(self):
        return f'<html>\n{str(self.subelement)}\n</html>'

class body:
    def __init__(self, text, subelement=None):
        self.text = text
        self.subelement = subelement
    def __str__(self):
        sub = ''
        if self.subelement:
            sub = f'\n{str(self.subelement)}'
        return f'<body>\n{self.text}{sub}\n</body>'

class p:
    def __init__(self, text):
        self.text = text
    def __str__(self):
        return f'<p>\n{self.text}\n</p>'

para = p(text="this is some body text")
doc_body = body(text="This is the body", subelement=para)
doc = html(subelement=doc_body)
print(doc)

